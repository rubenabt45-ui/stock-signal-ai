import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    console.log('üöÄ Edge function started - initializing...');
    
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
    )

    // Enhanced API key validation
    const finnhubApiKey = Deno.env.get('FINNHUB_API_KEY')
    console.log('üîë Environment check - Finnhub API key exists:', !!finnhubApiKey)
    
    if (!finnhubApiKey) {
      console.error('‚ùå CRITICAL: FINNHUB_API_KEY not found in environment')
      throw new Error('Finnhub API key not configured in Supabase Vault')
    }
    
    console.log('üîë Finnhub API key preview:', finnhubApiKey.substring(0, 8) + '...')
    console.log('üîë Finnhub API key length:', finnhubApiKey.length)
    
    // Validate API key format (should be alphanumeric)
    if (!/^[a-zA-Z0-9]+$/.test(finnhubApiKey)) {
      console.error('‚ùå CRITICAL: Invalid API key format detected');
      throw new Error('Invalid Finnhub API key format');
    }

    // Test API key with HTTP request first
    console.log('üß™ Testing API key with HTTP request...');
    try {
      const testUrl = `https://finnhub.io/api/v1/quote?symbol=AAPL&token=${finnhubApiKey}`;
      const testResponse = await fetch(testUrl);
      console.log('üß™ API test response status:', testResponse.status);
      
      if (testResponse.status === 401) {
        console.error('‚ùå CRITICAL: API key authentication failed (401)');
        throw new Error('Invalid Finnhub API key - authentication failed');
      } else if (testResponse.status === 403) {
        console.error('‚ùå CRITICAL: API key lacks permissions (403)');
        throw new Error('Finnhub API key lacks required permissions');
      } else if (testResponse.status === 429) {
        console.error('‚ö†Ô∏è WARNING: Rate limit exceeded (429)');
      } else if (testResponse.ok) {
        const testData = await testResponse.json();
        console.log('‚úÖ API key validation successful, sample data:', testData);
      }
    } catch (apiError) {
      console.error('‚ùå API key validation failed:', apiError);
      throw new Error(`API key validation failed: ${apiError.message}`);
    }

    if (req.headers.get("upgrade") !== "websocket") {
      return new Response("Expected websocket", { status: 400 })
    }

    console.log('üîå Upgrading to WebSocket connection...');
    const { socket, response } = Deno.upgradeWebSocket(req)
    
    let symbols: string[] = []
    let finnhubWs: WebSocket | null = null
    let priceCache: Record<string, any> = {}
    let keepAliveInterval: number | null = null
    let reconnectTimeout: number | null = null
    let reconnectAttempts = 0
    const maxReconnectAttempts = 5
    let isManualClose = false

    const sendDebugMessage = (message: string) => {
      console.log('üîç DEBUG:', message);
      try {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({
            type: 'debug',
            message: message,
            timestamp: new Date().toISOString()
          }));
        }
      } catch (err) {
        console.error('Failed to send debug message:', err);
      }
    };

    const sendErrorMessage = (error: string) => {
      console.error('‚ùå ERROR:', error);
      try {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({
            type: 'error',
            error: error,
            timestamp: new Date().toISOString()
          }));
        }
      } catch (err) {
        console.error('Failed to send error message:', err);
      }
    };

    // Enhanced keep-alive for Finnhub connection
    const startFinnhubKeepAlive = () => {
      if (keepAliveInterval) {
        clearInterval(keepAliveInterval);
      }
      console.log('üíì Starting Finnhub keep-alive interval (20 seconds)');
      keepAliveInterval = setInterval(() => {
        if (finnhubWs && finnhubWs.readyState === WebSocket.OPEN) {
          console.log('üíì Sending ping to Finnhub');
          try {
            finnhubWs.send(JSON.stringify({ type: 'ping' }));
          } catch (err) {
            console.error('‚ùå Failed to send ping to Finnhub:', err);
          }
        } else {
          console.log('üíì Finnhub WebSocket not ready for ping');
        }
      }, 20000); // 20 seconds
    };

    const stopFinnhubKeepAlive = () => {
      if (keepAliveInterval) {
        console.log('üõë Stopping Finnhub keep-alive interval');
        clearInterval(keepAliveInterval);
        keepAliveInterval = null;
      }
    };

    const subscribeToSymbols = () => {
      if (finnhubWs && finnhubWs.readyState === WebSocket.OPEN && symbols.length > 0) {
        console.log('üì° Re-subscribing to symbols after reconnect:', symbols);
        symbols.forEach(symbol => {
          const subscribeMsg = JSON.stringify({'type':'subscribe','symbol': symbol});
          console.log(`üì° Sending subscription for ${symbol}:`, subscribeMsg);
          try {
            finnhubWs?.send(subscribeMsg);
            sendDebugMessage(`üì° Re-subscribed to ${symbol} after reconnect`);
          } catch (err) {
            console.error(`‚ùå Failed to subscribe to ${symbol}:`, err);
            sendErrorMessage(`Failed to subscribe to ${symbol}: ${err.message}`);
          }
        });
      }
    };

    const connectToFinnhub = () => {
      if (isManualClose) {
        console.log('üõë Manual close detected, not reconnecting');
        return;
      }

      if (reconnectAttempts >= maxReconnectAttempts) {
        console.error('‚ùå Max Finnhub reconnection attempts reached');
        sendErrorMessage('‚ùå Max Finnhub reconnection attempts reached');
        return;
      }

      const finnhubWsUrl = `wss://ws.finnhub.io?token=${finnhubApiKey}`;
      console.log('üîå Connecting to Finnhub WebSocket...');
      console.log('üåê Finnhub WS URL structure: wss://ws.finnhub.io?token=', finnhubApiKey?.substring(0, 8) + '...');
      
      sendDebugMessage(`Connecting to Finnhub (attempt ${reconnectAttempts + 1}/${maxReconnectAttempts})`);
      
      try {
        finnhubWs = new WebSocket(finnhubWsUrl);
        
        finnhubWs.onopen = () => {
          console.log('‚úÖ Successfully connected to Finnhub WebSocket!');
          sendDebugMessage('‚úÖ Connected to Finnhub WebSocket successfully');
          reconnectAttempts = 0; // Reset on successful connection
          
          // Start keep-alive
          startFinnhubKeepAlive();
          
          // Subscribe to symbols when connection opens
          subscribeToSymbols();
        };

        finnhubWs.onmessage = async (event) => {
          try {
            const data = JSON.parse(event.data);
            console.log('üì® Raw message from Finnhub:', data);
            
            if (data.type === 'trade' && data.data && data.data.length > 0) {
              console.log(`üìà Processing ${data.data.length} trade(s) from Finnhub`);
              sendDebugMessage(`üìà Received ${data.data.length} trades from Finnhub`);
              
              for (const trade of data.data) {
                const symbol = trade.s;
                const price = trade.p;
                const volume = trade.v;
                const timestamp = trade.t;

                console.log(`üíπ Trade received: ${symbol} @ $${price} (vol: ${volume}, time: ${timestamp})`);
                sendDebugMessage(`üíπ Live trade: ${symbol} = $${price}`);

                // Get or create price cache entry
                if (!priceCache[symbol]) {
                  const initialQuote = await getInitialQuote(symbol);
                  if (initialQuote) {
                    priceCache[symbol] = initialQuote;
                  }
                }

                // Update with real-time trade price
                if (priceCache[symbol]) {
                  const cachedPrice = priceCache[symbol];
                  const change = price - cachedPrice.previousClose;
                  const changePercent = cachedPrice.previousClose ? (change / cachedPrice.previousClose) * 100 : 0;

                  const priceData = {
                    symbol,
                    currentPrice: price,
                    change,
                    changePercent,
                    high: Math.max(cachedPrice.high, price),
                    low: Math.min(cachedPrice.low, price),
                    open: cachedPrice.open,
                    previousClose: cachedPrice.previousClose,
                    timestamp: Date.now()
                  };

                  priceCache[symbol] = priceData;

                  console.log(`üì§ Sending live price update to client:`, priceData);

                  // Send to client
                  if (socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                      type: 'price_update',
                      symbol,
                      data: priceData
                    }));
                  }

                  // Store in database
                  try {
                    await supabaseClient
                      .from('price_updates')
                      .upsert({
                        symbol,
                        current_price: price,
                        change,
                        change_percent: changePercent,
                        high: priceData.high,
                        low: priceData.low,
                        open: priceData.open,
                        previous_close: priceData.previousClose,
                        timestamp: new Date().toISOString()
                      });
                  } catch (dbError) {
                    console.error('‚ùå Database storage error:', dbError);
                  }
                }
              }
            } else if (data.type === 'ping') {
              console.log('üèì Received ping from Finnhub');
              sendDebugMessage('üèì Finnhub ping received');
            } else if (data.type === 'error') {
              console.error('‚ùå Error from Finnhub:', data);
              sendErrorMessage(`Finnhub error: ${JSON.stringify(data)}`);
            } else {
              console.log('üì® Other message type from Finnhub:', data.type, data);
              sendDebugMessage(`üì® Finnhub message: ${data.type}`);
            }
          } catch (error) {
            console.error('‚ùå Error processing Finnhub message:', error, 'Raw event:', event.data);
            sendDebugMessage(`‚ùå Error processing Finnhub message: ${error.message}`);
          }
        };

        finnhubWs.onclose = (event) => {
          console.log('üîå Finnhub WebSocket closed:', event.code, event.reason, 'Clean:', event.wasClean);
          sendDebugMessage(`üîå Finnhub connection closed: ${event.code} - ${event.reason}`);
          stopFinnhubKeepAlive();
          
          // Enhanced error code handling
          if (event.code === 1000) {
            console.log('‚úÖ Normal closure, not reconnecting');
            return;
          } else if (event.code === 1006) {
            console.log('‚ö†Ô∏è Abnormal closure detected (1006)');
            sendErrorMessage('Connection lost unexpectedly (1006)');
          } else if (event.code === 1011) {
            console.error('‚ùå Server error (1011)');
            sendErrorMessage('Server encountered an error (1011)');
          } else if (event.code === 4001) {
            console.error('‚ùå Invalid API key (4001)');
            sendErrorMessage('Invalid API key - check configuration');
            return; // Don't reconnect on auth failure
          }
          
          // Reconnect with exponential backoff if not a permanent failure
          if (!isManualClose && reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 30000); // Exponential backoff, max 30s
            console.log(`üîÑ Scheduling Finnhub reconnection in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
            sendDebugMessage(`üîÑ Reconnecting to Finnhub in ${delay}ms...`);
            
            reconnectTimeout = setTimeout(() => {
              console.log('üîÑ Reconnecting to Finnhub...');
              connectToFinnhub();
            }, delay);
          } else {
            console.error('‚ùå Finnhub connection failed permanently');
            sendErrorMessage('‚ùå Finnhub connection failed permanently');
          }
        };

        finnhubWs.onerror = (error) => {
          console.error('‚ùå Finnhub WebSocket error:', error);
          sendErrorMessage(`‚ùå Finnhub WebSocket error: ${error}`);
          stopFinnhubKeepAlive();
        };
      } catch (err) {
        console.error('‚ùå Failed to create Finnhub WebSocket:', err);
        sendErrorMessage(`Failed to create WebSocket: ${err.message}`);
      }
    };

    const getInitialQuote = async (symbol: string) => {
      try {
        console.log(`üìä Fetching initial quote for ${symbol} from Finnhub REST API...`);
        const quoteUrl = `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${finnhubApiKey}`;
        
        const response = await fetch(quoteUrl);
        console.log(`üìà Quote API response status for ${symbol}:`, response.status);
        
        if (response.status === 401) {
          console.error(`‚ùå Unauthorized access for ${symbol} - invalid API key`);
          sendErrorMessage(`Unauthorized access for ${symbol} - check API key`);
          return null;
        } else if (response.status === 403) {
          console.error(`‚ùå Forbidden access for ${symbol} - insufficient permissions`);
          sendErrorMessage(`Forbidden access for ${symbol} - insufficient permissions`);
          return null;
        } else if (response.status === 429) {
          console.error(`‚ùå Rate limit exceeded for ${symbol}`);
          sendErrorMessage(`Rate limit exceeded for ${symbol}`);
          return null;
        }
        
        if (response.ok) {
          const data = await response.json();
          console.log(`üí∞ Quote data for ${symbol}:`, data);
          
          if (data.c === 0 && data.d === 0) {
            console.warn(`‚ö†Ô∏è Warning: ${symbol} returned zero values - may be invalid symbol or market closed`);
          }
          
          return {
            symbol,
            currentPrice: data.c || 0,
            change: data.d || 0,
            changePercent: data.dp || 0,
            high: data.h || 0,
            low: data.l || 0,
            open: data.o || 0,
            previousClose: data.pc || 0,
            timestamp: Date.now()
          };
        } else {
          const errorText = await response.text();
          console.error(`‚ùå Quote API failed for ${symbol}:`, response.status, errorText);
          sendErrorMessage(`‚ùå Quote API failed for ${symbol}: ${response.status} - ${errorText}`);
        }
      } catch (error) {
        console.error(`‚ùå Exception fetching quote for ${symbol}:`, error);
        sendErrorMessage(`‚ùå Exception fetching quote for ${symbol}: ${error.message}`);
      }
      return null;
    };

    socket.onopen = () => {
      console.log("‚úÖ Client WebSocket connection established");
      sendDebugMessage('‚úÖ Edge function WebSocket connection established');
      connectToFinnhub();
    };

    socket.onmessage = async (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('üì® Message from client:', data);
        
        if (data.type === 'subscribe') {
          symbols = data.symbols || [];
          console.log('üì° Client subscribing to symbols:', symbols);
          sendDebugMessage(`üì° Subscribing to symbols: ${symbols.join(', ')}`);
          
          // Get initial quotes and send to client
          for (const symbol of symbols) {
            const initialQuote = await getInitialQuote(symbol);
            if (initialQuote) {
              priceCache[symbol] = initialQuote;
              
              console.log(`üì§ Sending initial quote for ${symbol}:`, initialQuote);
              
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                  type: 'price_update',
                  symbol,
                  data: initialQuote
                }));
              }
            }
          }
          
          // Subscribe to Finnhub for real-time trades
          subscribeToSymbols();
        } else if (data.type === 'ping') {
          console.log('üèì Received ping from client, sending pong');
          if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'pong', timestamp: Date.now() }));
          }
        }
      } catch (error) {
        console.error('‚ùå Error processing client message:', error);
        sendDebugMessage(`‚ùå Error processing client message: ${error.message}`);
      }
    };

    socket.onclose = () => {
      console.log("üîå Client WebSocket connection closed");
      isManualClose = true;
      stopFinnhubKeepAlive();
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
      }
      if (finnhubWs) {
        symbols.forEach(symbol => {
          try {
            finnhubWs?.send(JSON.stringify({'type':'unsubscribe','symbol': symbol}));
          } catch (err) {
            console.error('Error unsubscribing:', err);
          }
        });
        finnhubWs.close();
      }
    };

    return response;
  } catch (error) {
    console.error('‚ùå Edge function error:', error);
    return new Response(
      JSON.stringify({ 
        error: error.message,
        details: 'Check Supabase Edge Function logs for more information'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      },
    );
  }
});
